
export default function Components() {
	@render {
		<div>
			<:head>
				<title>Components</title>
			</:head>

			<h1>Components</h1>
			<p>
				Each component is a JavaScript function located in a file with the `.tera`
				extension. The function is responsible for storing the component's state, building
				and updating the component's HTML, and scoping CSS styles.
			</p>

			<h2>The Function</h2>
			<p>
				The component function should look something like this:
			</p>
			<pre><code>
{`
export default function Component() {
	// ...
}
`.trim()}
			</code></pre>
			<p>
				The function's name must start with an uppercase letter to be considered a
				component.
			</p>
			<p>
				The component should be exported if it is to be used outside the file. You can use
				any combination of `export default`, `export` and unexported functions for
				components in a Tera file. For example, a child component that is used only in the
				current file can be declared like this:
			</p>
			<pre><code>
{`
function ChildComponent() {
	// ...
}
`.trim()}
			</code></pre>

			<h2>Markup</h2>
			<p>
				The HTML that a component outputs is declared within a `@render` block. There can
				only be one @render block per component. Each @render block must contain a single
				root element:
			</p>
			<pre><code>
{`
export default function Component() {
	@render {
		<p>Hello!</p>
	}
}
`.trim()}
			</code></pre>
			<p>
				You can include dynamic content in text and attributes using braces:
			</p>
			<pre><code>
{`
export default function Component() {
	const className = "extravagant"
	const name = "Andrew"

	@render {
		<p class={className}>
			Hello, {name}!
		</p>
	}
}
`.trim()}
			</code></pre>
			<p>
				See the <a href="/docs/markup">Markup</a> section for more on what you can do in
				the @render block.
			</p>

			<h2>State</h2>
			<p>
				Data that is stored within a component is called its `state`. State can be simple
				variables, as above, or it can be made reactive with the $watch function:
			</p>
			<pre><code>
{`
export default function Component() {
	const $state = $watch({
		count: 1
	})

	@render {
		<div>
			<p>
				The count is {$state.count}.
			</p>
			<button onclick={() => $state.count++}>
				Increment
			</button>
		</div>
	}
}
`.trim()}
			</code></pre>
			<p>
				The $watch function is automatically imported into component files if used (along
				with a few other functions). By convention, reactive objects should start with a
				`$` so that it is easy to see at a glance which statements are reactive in your
				markup.
			</p>
			<p>
				A component function can accept a $props component containing the properties that
				were passed to the component:
			</p>
			<pre><code>
{`
export default function Component($props: { name: string }) {
	@render {
		<p>
			Hello, {name}!
		</p>
	}
}
`.trim()}
			</code></pre>
			<p>
				See the <a href="/docs/state">State</a> section for more on how to manage component
				state.
			</p>

			<h2>Styles</h2>
			<p>
				The CSS for styling a component's elements is declared with a `@style` block. There
				can only be one @style block per component:
			</p>
			<pre><code>
{`
export default function Component() {
	@render {
		<p class="extravagant">Hello!</p>
	}

	@style {
		.extravagant: {
			size: x-large;
			color: purple;
		}
	}
}
`.trim()}
			</code></pre>
			<p>
				The styles in the style block are scoped to the elements in the component so that
				they don't affect elements in other components.
			</p>
			<p>
				See the <a href="/docs/styles">Styles</a> section for more on what you can do in
				the @style block.
			</p>
		</div>
	}
}
