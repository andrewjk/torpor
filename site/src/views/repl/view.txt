
const context = {
	activeTarget: null,
	previousEffect: null,
	extent: 0,
	batch: 0,
	batchOperation: 0,
	registerComputed: null,
	firstEffectToRun: null,
	firstSignalToUpdate: null,
	activeRange: null,
	previousRange: null,
	rootRange: null,
	mountEffects: [],
	stashedEvents: [],
	stashedAnimations: [],
	hydrationNode: null
};
var context_default = context;
const SIGNAL_TYPE = 0;
const COMPUTED_TYPE = 1;
const EFFECT_TYPE = 2;
function clearSources(target) {
	let previousSub = null;
	for (let clearSub = target.firstSource; clearSub !== null; clearSub = clearSub.nextSource) if (target.didError || !clearSub.active) {
		if (previousSub === null) target.firstSource = clearSub.nextSource;
		else previousSub.nextSource = clearSub.nextSource;
		if (clearSub.previousTarget === null) {
			if (clearSub.source.firstTarget === clearSub) clearSub.source.firstTarget = clearSub.nextTarget;
		} else clearSub.previousTarget.nextTarget = clearSub.nextTarget;
	} else {
		clearSub.recalc = false;
		previousSub = clearSub;
	}
}
function deactivateSources(target) {
	for (let sourceSub = target.firstSource; sourceSub !== null; sourceSub = sourceSub.nextSource) sourceSub.active = false;
}
function trackEffect(signal) {
	const target = context_default.activeTarget;
	if (target !== null) {
		let sub = null;
		let lastSub = null;
		for (let nextSub = signal.firstTarget; nextSub !== null; nextSub = nextSub.nextTarget) {
			lastSub = nextSub;
			if (nextSub.target === target) {
				sub = nextSub;
				break;
			}
		}
		if (sub === null) {
			sub = {
				source: signal,
				target,
				previousTarget: lastSub,
				nextTarget: null,
				nextSource: null,
				active: true,
				recalc: false
			};
			if (lastSub === null) signal.firstTarget = sub;
			else lastSub.nextTarget = sub;
			if (target.firstSource === null) target.firstSource = sub;
			else {
				let lastEffectSub = target.firstSource;
				for (let nextSub = lastEffectSub.nextSource; nextSub !== null; nextSub = nextSub.nextSource) lastEffectSub = nextSub;
				lastEffectSub.nextSource = sub;
			}
		} else sub.active = true;
	}
}
function runComputed(computed) {
	const oldActiveTarget = context_default.activeTarget;
	computed.running = true;
	computed.didError = false;
	try {
		context_default.activeTarget = computed;
		computed.value = computed.run();
	} catch (err) {
		computed.didError = true;
		computed.value = err;
		throw err;
	} finally {
		context_default.activeTarget = oldActiveTarget;
		computed.running = false;
	}
	trackEffect(computed);
	return computed.value;
}
function checkComputed(computed) {
	let rerun = checkSources(computed);
	let changed = false;
	if (rerun) {
		deactivateSources(computed);
		const oldValue = computed.value;
		runComputed(computed);
		changed = computed.value !== oldValue;
		clearSources(computed);
	}
	computed.recalc = false;
	if (!changed) for (let targetSub = computed.firstTarget; targetSub !== null; targetSub = targetSub.nextTarget) {
		targetSub.active = true;
		targetSub.recalc = false;
	}
	return changed;
}
function checkSources(target) {
	let haveComputed = false;
	for (let sourceSub = target.firstSource; sourceSub !== null; sourceSub = sourceSub.nextSource) if (sourceSub.recalc) if (sourceSub.source.type === SIGNAL_TYPE) return true;
	else if (sourceSub.source.recalc) haveComputed = true;
	else return true;
	if (haveComputed) {
		for (let sourceSub = target.firstSource; sourceSub !== null; sourceSub = sourceSub.nextSource) if (sourceSub.recalc && sourceSub.source.type === COMPUTED_TYPE && sourceSub.source.recalc) {
			const oldActiveTarget = context_default.activeTarget;
			context_default.activeTarget = target;
			const recalc = checkComputed(sourceSub.source);
			context_default.activeTarget = oldActiveTarget;
			if (recalc) return true;
		}
	}
	return false;
}
function runCleanups(effect) {
	let effectToClean = effect;
	for (let i = 0; i < effect.extent; i++) {
		if (typeof effectToClean.cleanup === "function") {
			const oldActiveTarget = context_default.activeTarget;
			context_default.activeTarget = null;
			try {
				effectToClean.cleanup();
			} catch (err) {
				effectToClean.didError = true;
				clearSources(effectToClean);
				throw err;
			} finally {
				effectToClean.cleanup = void 0;
				context_default.activeTarget = oldActiveTarget;
			}
		}
		const nextEffect = effectToClean.nextEffect;
		if (i !== 0 && effect.nextEffectToRun === effectToClean) {
			effect.nextEffectToRun = effectToClean.nextEffectToRun;
			effectToClean.nextEffect = effectToClean.nextEffectToRun = null;
		}
		effectToClean = nextEffect;
	}
}
function batchStart() {
	context_default.batch++;
}
function runEffect(effect) {
	const oldActiveTarget = context_default.activeTarget;
	const oldExtent = context_default.extent;
	effect.didError = false;
	batchStart();
	try {
		if (context_default.previousEffect !== null) context_default.previousEffect.nextEffect = effect;
		context_default.activeTarget = effect;
		context_default.previousEffect = effect;
		context_default.extent = 1;
		effect.cleanup = effect.run();
		effect.extent = context_default.extent;
	} catch (err) {
		effect.didError = true;
		clearSources(effect);
		throw err;
	} finally {
		context_default.activeTarget = oldActiveTarget;
		context_default.extent += oldExtent;
		batchEnd();
	}
}
function checkEffect(effect) {
	if (checkSources(effect)) {
		runCleanups(effect);
		deactivateSources(effect);
		runEffect(effect);
		clearSources(effect);
	}
}
function clearTargets(source) {
	let previousSub = null;
	for (let clearSub = source.firstTarget; clearSub !== null; clearSub = clearSub.nextTarget) if (!clearSub.active) if (previousSub === null) source.firstTarget = clearSub.nextTarget;
	else previousSub.nextTarget = clearSub.nextTarget;
	else previousSub = clearSub;
}
function triggerEffects() {
	let didError = false;
	let error;
	let effect = context_default.firstEffectToRun;
	while (effect !== null) {
		context_default.batchOperation++;
		try {
			checkEffect(effect);
		} catch (err) {
			if (!didError) {
				didError = true;
				error = err;
			}
		}
		effect = effect.nextEffectToRun;
	}
	effect = context_default.firstEffectToRun;
	context_default.firstEffectToRun = null;
	while (effect !== null) {
		let nextEffect = effect.nextEffectToRun;
		effect.nextEffectToRun = null;
		effect = nextEffect;
	}
	let signal = context_default.firstSignalToUpdate;
	context_default.firstSignalToUpdate = null;
	while (signal !== null) {
		clearTargets(signal);
		const nextSignal = signal.nextSignalToUpdate;
		signal.nextSignalToUpdate = null;
		signal = nextSignal;
	}
	if (didError) throw error;
}
function batchEnd() {
	if (context_default.batch > 1) {
		context_default.batch--;
		return;
	}
	try {
		triggerEffects();
	} finally {
		context_default.batch = 0;
		context_default.batchOperation = 0;
		context_default.previousEffect = null;
	}
}
function $batch(fn) {
	if (context_default.batch > 0) return fn();
	batchStart();
	try {
		return fn();
	} finally {
		batchEnd();
	}
}
function $cache(fn) {
	if (context_default.registerComputed === null) throw new Error("$cache must be used in a getter");
	let computed = {
		type: COMPUTED_TYPE,
		value: null,
		run: fn,
		firstSource: null,
		firstTarget: null,
		recalc: false,
		running: false,
		didError: false,
		rollback: null
	};
	context_default.registerComputed(computed);
	runComputed(computed);
	return computed.value;
}
function $peek(fn) {
	const oldActiveTarget = context_default.activeTarget;
	context_default.activeTarget = null;
	const result = fn();
	context_default.activeTarget = oldActiveTarget;
	return result;
}
function buildClasses(value, styleHash) {
	if (typeof value === "string") {
		if (styleHash !== void 0) value += " " + styleHash;
		return value;
	} else {
		let classes = [];
		gatherNames("", value, classes);
		if (styleHash !== void 0) classes.push(styleHash);
		return classes.join(" ");
	}
}
function gatherNames(name, value, classes) {
	if (value) if (Array.isArray(value)) for (let v of value) gatherNames(v, v, classes);
	else if (typeof value === "object") for (let [n, v] of Object.entries(value)) gatherNames(n, v, classes);
	else classes.push(name);
}
function buildStyles(value) {
	if (typeof value === "string") return value;
	else {
		let styles = [];
		if (value) {
			if (Array.isArray(value)) for (let v of value) styles.push(v);
			else if (typeof value === "object") for (let [n, v] of Object.entries(value)) styles.push(`${n}: ${v}`);
		}
		return styles.join("; ");
	}
}
function formatText(value) {
	return value ?? "";
}
function $mount(fn) {
	context_default.mountEffects.push(fn);
}
function $run(fn, name) {
	let effect = {
		type: EFFECT_TYPE,
		run: fn,
		cleanup: void 0,
		firstSource: null,
		nextEffect: null,
		extent: 0,
		nextEffectToRun: null,
		didError: false,
		name
	};
	runEffect(effect);
	return effect;
}
const proxyDataSymbol = Symbol("_proxy_data");
const proxyHandledSymbol = Symbol("_proxy_handled");
function $unwrap(object) {
	return object !== void 0 && object !== null && object[proxyDataSymbol] !== void 0 ? object[proxyDataSymbol].target ?? object : object;
}
function trackProxyEffect(data, key) {
	let signal = data.signals.get(key);
	if (signal === void 0) {
		signal = {
			type: SIGNAL_TYPE,
			firstTarget: null,
			nextSignalToUpdate: null
		};
		data.signals.set(key, signal);
	}
	trackEffect(signal);
}
let lastEffect;
function updateSignal(proxy, key) {
	let signal = proxy.signals.get(key);
	if (signal !== void 0 && signal.firstTarget !== null) {
		batchStart();
		try {
			if (context_default.firstSignalToUpdate === null) context_default.firstSignalToUpdate = signal;
			else if (signal.nextSignalToUpdate === null) {
				let lastSignal = context_default.firstSignalToUpdate;
				while (lastSignal.nextSignalToUpdate !== null) lastSignal = lastSignal.nextSignalToUpdate;
				lastSignal.nextSignalToUpdate = signal;
			}
			lastEffect = context_default.firstEffectToRun;
			if (lastEffect !== null) while (lastEffect.nextEffectToRun !== null) lastEffect = lastEffect.nextEffectToRun;
			let targetSub = signal.firstTarget;
			let computed;
			outer: while (true) {
				targetSub.active = false;
				targetSub.recalc = true;
				const target = targetSub.target;
				if (target.type === EFFECT_TYPE) {
					if (lastEffect === null) {
						context_default.firstEffectToRun = target;
						lastEffect = target;
					} else if (target.nextEffectToRun === null && lastEffect !== target) {
						lastEffect.nextEffectToRun = target;
						lastEffect = target;
					}
				} else if (!target.recalc) {
					target.recalc = true;
					if (target.firstTarget !== null) {
						computed = target;
						computed.rollback = targetSub;
						targetSub = target.firstTarget;
						continue;
					}
				}
				while (targetSub.nextTarget === null && computed !== void 0) {
					targetSub = computed.rollback;
					if (targetSub.source.type !== COMPUTED_TYPE) {
						computed = void 0;
						continue outer;
					}
					computed = targetSub.source;
				}
				if (targetSub.nextTarget === null) break;
				targetSub = targetSub.nextTarget;
			}
		} finally {
			batchEnd();
		}
	}
}
function proxyGet(target, key, receiver) {
	let data = target[proxyDataSymbol];
	if (key === proxyDataSymbol) return data;
	let signal = data.signals.get(key);
	if (signal === void 0) {
		const propDescriptor = Object.getOwnPropertyDescriptor(target, key);
		if (propDescriptor !== void 0) {
			if (propDescriptor.writable) {
				if (data.shallow !== true) {
					const value = target[key];
					if (value !== void 0 && value !== null && typeof value === "object" && value[proxyDataSymbol] === void 0 && value.then === void 0) target[key] = $watch(value);
				}
				trackProxyEffect(data, key);
			} else if (propDescriptor.get) {
				const oldRegisterComputed = context_default.registerComputed;
				try {
					context_default.registerComputed = (computed) => {
						data.signals.set(key, computed);
					};
					return Reflect.get(target, key, receiver);
				} finally {
					context_default.registerComputed = oldRegisterComputed;
				}
			}
		} else if (data.isArray) {
			if (arrayWrapper[key] !== void 0) return arrayWrapper[key](data, target, key);
		}
	} else if (signal.type === SIGNAL_TYPE) trackProxyEffect(data, key);
	else if (signal.type === COMPUTED_TYPE) {
		if (signal.running) throw new Error("Cycle detected");
		else if (signal.recalc) checkComputed(signal);
		else if (signal.didError) throw signal.value;
		else trackEffect(signal);
		return signal.value;
	}
	return Reflect.get(target, key, receiver);
}
const arrayWrapper = {
	[Symbol.iterator]: function(data, target, key) {
		trackProxyEffect(data, "length");
		context_default.activeTarget = null;
		return target[key];
	},
	pop: arrayHandle,
	push: arrayHandle,
	reverse: arrayHandle,
	shift: arrayHandle,
	sort: arrayHandle,
	splice: arrayHandle,
	unshift: arrayHandle
};
function arrayHandle(data, target, key) {
	return function(...args) {
		const result = target[key].apply(target, args);
		updateSignal(data, "length");
		return result;
	};
}
function proxySet(target, key, value, receiver) {
	const oldValue = target[key];
	if (value !== oldValue) {
		if (context_default.batchOperation > 100) throw new Error("Cycle detected");
		let data = target[proxyDataSymbol];
		if (oldValue && oldValue[proxyDataSymbol] !== void 0) value = $watch(value, { shallow: oldValue[proxyDataSymbol].shallow });
		Reflect.set(target, key, value, receiver);
		updateSignal(data, key);
		if (data.isArray && !isNaN(+String(key))) updateSignal(data, "length");
	}
	return true;
}
function $watch(object, options) {
	if (object === void 0 || object === null || object[proxyDataSymbol] !== void 0) return object;
	object[proxyDataSymbol] = {
		target: object,
		isArray: Array.isArray(object),
		shallow: options?.shallow === true,
		signals: /* @__PURE__ */ new Map()
	};
	const handler = {
		get: proxyGet,
		set: proxySet
	};
	return new Proxy(object, handler);
}
function addAnimation(el, entry, exit) {
	context_default.stashedAnimations.push({
		range: context_default.activeRange,
		el,
		in: entry,
		out: exit
	});
}
function addEvent(el, type, listener) {
	context_default.stashedEvents.push({
		range: context_default.activeRange,
		el,
		type,
		listener
	});
}
async function animate(el, enter, keyframes, options) {
	let animationOptions = Object.assign({
		direction: enter ? "normal" : "reverse",
		duration: 300,
		easing: "ease-in-out",
		fill: "forwards"
	}, options);
	const animation = el.animate(keyframes, animationOptions);
	setTimeout(() => {
		animation.timeline = el.ownerDocument.timeline;
	}, 1);
	let activeRange = context_default.activeRange;
	if (activeRange) {
		activeRange.animations ??= /* @__PURE__ */ new Set();
		activeRange.animations.add(animation);
		await animation.finished;
		activeRange.animations.delete(animation);
	}
}
function isFragmentNode(node) {
	return node.nodeType === 11;
}
function addFragment(fragment, parent, before, endNode) {
	const range = context_default.activeRange;
	const hydrationNode = context_default.hydrationNode;
	if (hydrationNode !== null) range.endNode = endNode ?? hydrationNode;
	else {
		range.startNode = fragment.firstChild;
		range.endNode = fragment.lastChild;
	}
	parent = before?.parentNode ?? parent;
	if (hydrationNode === null) parent.insertBefore(fragment, before);
	if (!isFragmentNode(parent)) {
		if (hydrationNode === null) {
			for (let effect of context_default.mountEffects) $run(effect);
			context_default.mountEffects.length = 0;
		}
		for (let event of context_default.stashedEvents) {
			context_default.activeRange = event.range;
			$run(function addFragmentEvent() {
				event.el.addEventListener(event.type, event.listener);
				return () => {
					event.el.removeEventListener(event.type, event.listener);
				};
			});
		}
		context_default.stashedEvents.length = 0;
		for (let animation of context_default.stashedAnimations) {
			context_default.activeRange = animation.range;
			$run(function addFragmentAnimation() {
				if (animation.in !== void 0) animate(animation.el, true, animation.in.keyframes, animation.in.options);
				if (animation.out !== void 0) return () => {
					animate(animation.el, false, animation.out.keyframes, animation.out.options);
				};
			});
		}
		context_default.stashedAnimations.length = 0;
		context_default.activeRange = range;
	}
}
function applyProps(el, props, propNamesUsed) {
	if (props !== void 0) {
		for (let [name, value] of Object.entries(props)) if (!propNamesUsed.includes(name)) if (name.startsWith("on")) {
			const eventName = name.substring(2);
			el.addEventListener(eventName, value);
		} else $run(function setAttribute$1() {
			el.setAttribute(name, value);
		});
	}
}
function clearRange(range) {
	let animations = range.animations !== null ? Array.from(range.animations) : void 0;
	if (range.children > 0) {
		let nextRange = range.nextRange;
		for (let i = 1; i < range.children; i++) {
			if (nextRange.animations !== null) {
				animations ??= [];
				animations.push(...nextRange.animations);
			}
			let nr = nextRange.nextRange;
			releaseRange(nextRange);
			nextRange = nr;
		}
		range.nextRange = nextRange;
	}
	if (range.previousRange !== null) range.previousRange.nextRange = range.nextRange;
	if (range.nextRange !== null) range.nextRange.previousRange = range.previousRange;
	if (animations !== void 0) Promise.all(animations.map((a) => a.finished)).then(() => clearNodes(range));
	else clearNodes(range);
}
function clearNodes(range) {
	if (range.startNode !== null) {
		let currentNode = range.endNode ?? range.startNode;
		while (currentNode !== range.startNode) {
			let nextNode = currentNode.previousSibling;
			currentNode.remove();
			currentNode = nextNode;
		}
		currentNode.remove();
	}
	releaseRange(range);
}
function releaseRange(range) {
	range.startNode = null;
	range.endNode = null;
	range.previousRange = null;
	range.nextRange = null;
	range.animations = null;
}
function clearLayoutSlot(range) {
	clearRange(range);
}
function newRange(name) {
	return {
		startNode: null,
		endNode: null,
		previousRange: null,
		nextRange: null,
		children: 0,
		animations: null,
		name
	};
}
function popRange(oldRange) {
	context_default.activeRange = oldRange;
}
function pushRange(range, toParent = false) {
	const activeRange = context_default.activeRange;
	if (toParent) {
		const previousRange = context_default.previousRange;
		range.previousRange = previousRange;
		const nextRange = previousRange.nextRange;
		previousRange.nextRange = range;
		range.nextRange = nextRange;
		activeRange.children++;
	}
	context_default.activeRange = range;
	context_default.previousRange = range;
	return activeRange;
}
function fillLayoutSlot(component, slot, parent, anchor, $props, $context) {
	const range = newRange();
	const oldRange = pushRange(range);
	component(parent, anchor, $props, $context, { _: slot });
	popRange(oldRange);
	return range;
}
function getFragment(document, array, index, html, ns) {
	if (array[index] === void 0) if (ns === true) {
		const template = document.createElementNS("http://www.w3.org/2000/svg", "template");
		template.innerHTML = html;
		const fragment = new DocumentFragment();
		fragment.append(...template.childNodes);
		array[index] = fragment;
	} else {
		const template = document.createElement("template");
		template.innerHTML = html;
		array[index] = template.content;
	}
	return array[index].cloneNode(true);
}
function hydrate(parent, component, props, slots) {
	context_default.hydrationNode = parent.firstChild;
	context_default.rootRange = newRange();
	context_default.previousRange = context_default.rootRange;
	pushRange(context_default.rootRange);
	component(parent, null, props, void 0, slots);
	context_default.hydrationNode = null;
	for (let effect of context_default.mountEffects) $run(effect);
	context_default.mountEffects.length = 0;
}
function mount(parent, component, props, slots) {
	if (parent.childElementCount > 0) throw new Error("The parent node must have no child elements");
	while (parent.firstChild !== null) parent.firstChild.remove();
	context_default.rootRange = newRange();
	context_default.previousRange = context_default.rootRange;
	pushRange(context_default.rootRange);
	component(parent, null, props, void 0, slots);
}
function newListItem(data, key) {
	return {
		startNode: null,
		endNode: null,
		previousRange: null,
		nextRange: null,
		children: 0,
		animations: null,
		data,
		key
	};
}
const HYDRATION_START = "[";
const HYDRATION_END = "]";
const HYDRATION_BREAK = "^";
function isCommentNode(node) {
	return node.nodeType === 8;
}
function isTextNode(node) {
	return node.nodeType === 3;
}
function nodeCheckHydrationBreak(node) {
	if (context_default.hydrationNode !== null) {
		if (node !== null && isCommentNode(node) && node.data === HYDRATION_BREAK) {
			let comment = node;
			node = node.nextSibling;
			comment.remove();
		}
		context_default.hydrationNode = node;
	}
	return node;
}
function nodeNext(node, text = false) {
	if (context_default.hydrationNode !== null && text && isTextNode(node)) return node;
	return nodeCheckHydrationBreak(node.nextSibling);
}
function nodeAnchor(node) {
	if (context_default.hydrationNode !== null) {
		if (isCommentNode(node) && node.data === HYDRATION_START) {
			let currentNode = nodeNext(node);
			node.remove();
			let level = 1;
			while (currentNode !== null) {
				if (isCommentNode(currentNode)) {
					if (currentNode.data === HYDRATION_START) level += 1;
					else if (currentNode.data === HYDRATION_END) {
						level -= 1;
						if (level === 0) {
							const endNode = currentNode.nextSibling;
							currentNode.remove();
							if (context_default.hydrationNode === currentNode) context_default.hydrationNode = endNode;
							return endNode;
						}
					}
				}
				currentNode = currentNode.nextSibling;
			}
			if (currentNode === null) throw new Error("End hydration comment not found");
		}
	}
	return node;
}
function nodeChild(parent) {
	let childNode = parent.firstChild;
	if (context_default.hydrationNode !== null) {
		if (childNode === null) childNode = parent.appendChild(parent.ownerDocument.createTextNode(""));
		context_default.hydrationNode = childNode;
	}
	return childNode;
}
function nodeRoot(parent, text = false) {
	if (context_default.hydrationNode !== null) {
		let rootNode = context_default.hydrationNode;
		if (text && !isTextNode(rootNode) && rootNode.previousSibling !== null && isTextNode(rootNode.previousSibling)) {
			rootNode = rootNode.previousSibling;
			context_default.hydrationNode = rootNode;
		}
		if (isCommentNode(rootNode) && rootNode.data === HYDRATION_START) {
			rootNode = rootNode.nextSibling;
			context_default.hydrationNode = rootNode;
		}
		const range = context_default.activeRange;
		if (range.startNode === null) range.startNode = rootNode;
		return rootNode;
	} else return parent.firstChild;
}
function nodeSkip(node, count) {
	let nextNode = node;
	for (let i = 0; i < count; i++) nextNode = nodeCheckHydrationBreak(nextNode.nextSibling);
	return nextNode;
}
function runControl(range, anchor, create) {
	const oldRange = pushRange(range, true);
	$run(function runControl$1() {
		const oldBranchRange = pushRange(range);
		create(anchor);
		popRange(oldBranchRange);
	});
	if (context_default.hydrationNode) anchor = context_default.hydrationNode.nextSibling;
	popRange(oldRange);
}
function runControlBranch(range, create) {
	if (range.children === 1) {
		clearRange(range.nextRange);
		range.children = 0;
	}
	const oldRange = pushRange(newRange(), true);
	const oldTarget = context_default.activeTarget;
	context_default.activeTarget = null;
	create();
	context_default.activeTarget = oldTarget;
	popRange(oldRange);
}
function moveRange(parent, range, before) {
	parent = before?.parentNode ?? parent;
	const endNode = range.endNode ?? range.startNode;
	let currentNode = range.startNode;
	while (currentNode !== null) {
		const nextNode = currentNode.nextSibling;
		parent.insertBefore(currentNode, before);
		if (currentNode === endNode) break;
		currentNode = nextNode;
	}
}
function runListItems(range, parent, anchor, oldItems, newItems, create, update) {
	let oldStartIndex = 0;
	let oldEndIndex = oldItems.length - 1;
	let oldStartItem = oldItems[0];
	let oldEndItem = oldItems[oldEndIndex];
	let newStartIndex = 0;
	let newEndIndex = newItems.length - 1;
	let newStartItem = newItems[0];
	let newEndItem = newItems[newEndIndex];
	let oldKeyToIndex;
	let newKeyToIndex;
	while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) if (oldStartItem === null) oldStartItem = oldItems[++oldStartIndex];
	else if (oldEndItem === null) oldEndItem = oldItems[--oldEndIndex];
	else if (newStartItem === null) newStartItem = newItems[++newStartIndex];
	else if (newEndItem === null) newEndItem = newItems[--newEndIndex];
	else if (oldStartItem.key === newStartItem.key) {
		transferListItemData(oldStartItem, newStartItem, update);
		oldStartItem = oldItems[++oldStartIndex];
		newStartItem = newItems[++newStartIndex];
	} else if (oldEndItem.key === newEndItem.key) {
		transferListItemData(oldEndItem, newEndItem, update);
		oldEndItem = oldItems[--oldEndIndex];
		newEndItem = newItems[--newEndIndex];
	} else if (oldStartItem.key === newEndItem.key) {
		moveRange(parent, oldStartItem, oldEndItem.endNode.nextSibling);
		transferListItemData(oldStartItem, newEndItem, update);
		oldStartItem = oldItems[++oldStartIndex];
		newEndItem = newItems[--newEndIndex];
	} else if (oldEndItem.key === newStartItem.key) {
		moveRange(parent, oldEndItem, oldStartItem.startNode);
		transferListItemData(oldEndItem, newStartItem, update);
		oldEndItem = oldItems[--oldEndIndex];
		newStartItem = newItems[++newStartIndex];
	} else {
		if (oldKeyToIndex === void 0 || newKeyToIndex === void 0) {
			oldKeyToIndex = /* @__PURE__ */ new Map();
			for (let i = oldStartIndex; i < oldEndIndex; i++) oldKeyToIndex.set(oldItems[i].key, i);
			newKeyToIndex = /* @__PURE__ */ new Map();
			for (let i = newStartIndex; i < newEndIndex; i++) newKeyToIndex.set(newItems[i].key, i);
		}
		let oldIndex = oldKeyToIndex.get(newStartItem.key);
		let newIndex = newKeyToIndex.get(oldStartItem.key);
		if (oldIndex === void 0 && newIndex === void 0) {
			newStartItem.data = $watch(newStartItem.data, { shallow: true });
			create(newStartItem, oldStartItem.startNode);
			newStartItem.previousRange = oldStartItem.previousRange;
			newStartItem.nextRange = oldStartItem;
			oldStartItem.previousRange = newStartItem;
			clearRange(oldStartItem);
			oldStartItem = oldItems[++oldStartIndex];
			newStartItem = newItems[++newStartIndex];
		} else if (oldIndex === void 0) {
			newStartItem.data = $watch(newStartItem.data, { shallow: true });
			create(newStartItem, oldStartItem.startNode);
			newStartItem = newItems[++newStartIndex];
		} else if (newIndex === void 0) {
			clearRange(oldStartItem);
			oldStartItem = oldItems[++oldStartIndex];
		} else {
			const oldData = oldItems[oldIndex];
			moveRange(parent, oldData, oldStartItem.startNode);
			transferListItemData(oldData, newStartItem, update);
			oldItems[oldIndex] = null;
			newStartItem = newItems[++newStartIndex];
		}
	}
	if (oldStartIndex <= oldEndIndex || newStartIndex <= newEndIndex) if (oldStartIndex > oldEndIndex) {
		let before = oldStartItem?.startNode ?? oldItems[oldItems.length - 1]?.endNode?.nextSibling ?? anchor;
		for (; newStartIndex <= newEndIndex; newStartItem = newItems[++newStartIndex]) {
			newStartItem.data = $watch(newStartItem.data, { shallow: true });
			create(newStartItem, before);
			before = newStartItem.endNode.nextSibling;
		}
	} else for (; oldEndIndex >= oldStartIndex; oldStartItem = oldItems[oldEndIndex--]) clearRange(oldStartItem);
	range.children = newItems.length;
	if (newItems.length > 0) range.nextRange = newItems[0];
	else if (oldItems.length > 0) range.nextRange = oldItems[oldItems.length - 1].nextRange;
}
function transferListItemData(oldItem, newItem, update) {
	newItem.startNode = oldItem.startNode;
	newItem.endNode = oldItem.endNode;
	update(oldItem, newItem);
	newItem.data = oldItem.data;
}
function runList(range, parent, anchor, buildItems, create, update) {
	const oldRange = pushRange(range, true);
	let listItems = [];
	$run(function runList$1() {
		const oldBranchRange = pushRange(range);
		const newItems = buildItems();
		context_default.activeTarget = null;
		runListItems(range, parent, anchor, listItems, newItems, create, update);
		listItems = newItems;
		popRange(oldBranchRange);
	});
	if (context_default.hydrationNode !== null) anchor = context_default.hydrationNode.nextSibling;
	popRange(oldRange);
}
function setAttribute(el, name, value) {
	if (value === false || value === void 0 || value === null) el.removeAttribute(name);
	else el.setAttribute(name, value);
}
function setDynamicElement(el, tag) {
	if (context_default.hydrationNode !== null) return el;
	let newElement = el.ownerDocument.createElement(tag);
	el.replaceWith(newElement);
	return newElement;
}
let initialized = false;
var ReactiveDate = class ReactiveDate extends Date {
	constructor(...params) {
		super(...params);
		if (!initialized) this.#init();
		this[proxyHandledSymbol] = true;
		this[proxyDataSymbol] = {
			target: this,
			isArray: false,
			shallow: true,
			signals: /* @__PURE__ */ new Map()
		};
	}
	#init() {
		initialized = true;
		let reactivePrototype = ReactiveDate.prototype;
		let datePrototype = Date.prototype;
		const methods = Object.getOwnPropertyNames(datePrototype);
		for (const method of methods) {
			if (method.startsWith("get") || method.startsWith("to") || method === "valueOf") reactivePrototype[method] = function(...args) {
				const data = this[proxyDataSymbol];
				const result = datePrototype[method].apply(this, args);
				trackProxyEffect(data, "#time");
				return result;
			};
			if (method.startsWith("set")) reactivePrototype[method] = function(...args) {
				const data = this[proxyDataSymbol];
				const result = datePrototype[method].apply(this, args);
				updateSignal(data, "#time");
				return result;
			};
		}
	}
};
let t_add_fragment = addFragment;
let t_anchor = nodeAnchor;
let t_animate = addAnimation;
let t_apply_props = applyProps;
let t_attribute = setAttribute;
let t_child = nodeChild;
let t_class = buildClasses;
let t_dynamic = setDynamicElement;
let t_event = addEvent;
let t_fmt = formatText;
let t_fragment = getFragment;
let t_list_item = newListItem;
let t_next = nodeNext;
let t_pop_range = popRange;
let t_push_range = pushRange;
let t_range = newRange;
let t_root = nodeRoot;
let t_run_branch = runControlBranch;
let t_run_control = runControl;
let t_run_list = runList;
let t_skip = nodeSkip;
let t_style = buildStyles;
