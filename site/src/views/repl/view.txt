
function buildClasses(value, styleHash) {
	if (typeof value === "string") {
		if (styleHash !== void 0) value += " " + styleHash;
		return value;
	} else {
		let classes = [];
		gatherNames("", value, classes);
		if (styleHash !== void 0) classes.push(styleHash);
		return classes.join(" ");
	}
}
function gatherNames(name, value, classes) {
	if (value) if (Array.isArray(value)) for (let v of value) gatherNames(v, v, classes);
	else if (typeof value === "object") for (let [n, v] of Object.entries(value)) gatherNames(n, v, classes);
	else classes.push(name);
}
function buildStyles(value) {
	if (typeof value === "string") return value;
	else {
		let styles = [];
		if (value) {
			if (Array.isArray(value)) for (let v of value) styles.push(v);
			else if (typeof value === "object") for (let [n, v] of Object.entries(value)) styles.push(`${n}: ${v}`);
		}
		return styles.join("; ");
	}
}
function formatText(value) {
	return value ?? "";
}
function addAnimation(el, entry, exit) {
	context_default.stashedAnimations.push({
		region: context_default.activeRegion,
		el,
		in: entry,
		out: exit
	});
}
function addEvent(el, type, listener) {
	context_default.stashedEvents.push({
		region: context_default.activeRegion,
		el,
		type,
		listener
	});
}
async function animate(el, enter, keyframes, options) {
	let animationOptions = Object.assign({
		direction: enter ? "normal" : "reverse",
		duration: 300,
		easing: "ease-in-out",
		fill: "forwards"
	}, options);
	const animation = el.animate(keyframes, animationOptions);
	setTimeout(() => {
		animation.timeline = el.ownerDocument.timeline;
	}, 1);
	const activeRegion = context_default.activeRegion;
	activeRegion.animations ??= /* @__PURE__ */ new Set();
	activeRegion.animations.add(animation);
	await animation.finished;
}
function isFragmentNode(node) {
	return node.nodeType === 11;
}
function addFragment(fragment, parent, before, endNode) {
	const activeRegion = context_default.activeRegion;
	const hydrationNode = context_default.hydrationNode;
	if (hydrationNode !== null) activeRegion.endNode = endNode ?? hydrationNode;
	else {
		activeRegion.startNode = fragment.firstChild;
		activeRegion.endNode = fragment.lastChild;
	}
	parent = before?.parentNode ?? parent;
	if (hydrationNode === null) parent.insertBefore(fragment, before);
	if (!isFragmentNode(parent)) {
		if (hydrationNode === null) {
			for (let effect of context_default.mountEffects) $run(effect);
			context_default.mountEffects.length = 0;
		}
		for (let event of context_default.stashedEvents) {
			context_default.activeRegion = event.region;
			$run(function addFragmentEvent() {
				event.el.addEventListener(event.type, event.listener);
				return () => {
					event.el.removeEventListener(event.type, event.listener);
				};
			});
		}
		context_default.stashedEvents.length = 0;
		for (let animation of context_default.stashedAnimations) {
			context_default.activeRegion = animation.region;
			$run(function addFragmentAnimation() {
				if (animation.in !== void 0) animate(animation.el, true, animation.in.keyframes, animation.in.options);
				if (animation.out !== void 0) return () => {
					animate(animation.el, false, animation.out.keyframes, animation.out.options);
				};
			});
		}
		context_default.stashedAnimations.length = 0;
		context_default.activeRegion = activeRegion;
	}
}
function applyProps(el, props, propNamesUsed) {
	if (props !== void 0) {
		for (let [name, value] of Object.entries(props)) if (!propNamesUsed.includes(name)) if (name.startsWith("on")) {
			const eventName = name.substring(2);
			el.addEventListener(eventName, value);
		} else $run(function setAttribute$1() {
			el.setAttribute(name, value);
		});
	}
}
function clearRegion(region) {
	devContext_default.onRegionCleared(region);
	let animations = region.animations !== null ? Array.from(region.animations) : void 0;
	let childRegion = region.nextRegion;
	while (childRegion !== null && childRegion.depth > region.depth) {
		if (childRegion.animations !== null) {
			animations ??= [];
			animations.push(...childRegion.animations);
		}
		releaseRegion(childRegion);
		childRegion.depth = -2;
		childRegion = childRegion.nextRegion;
	}
	region.nextRegion = childRegion;
	if (region.previousRegion !== null) region.previousRegion.nextRegion = region.nextRegion;
	if (region.nextRegion !== null) region.nextRegion.previousRegion = region.previousRegion;
	if (animations !== void 0) {
		animations.forEach((a) => {
			a.reverse();
			a.play();
		});
		Promise.all(animations.map((a) => a.finished)).then(() => clearNodes(region));
	} else clearNodes(region);
}
function clearNodes(region) {
	if (region.startNode !== null && region.endNode !== null) {
		let currentNode = region.endNode;
		while (currentNode !== region.startNode) {
			let previousNode = currentNode.previousSibling;
			currentNode.remove();
			currentNode = previousNode;
		}
		currentNode.remove();
	}
	releaseRegion(region);
}
function releaseRegion(region) {
	region.startNode = null;
	region.endNode = null;
	region.previousRegion = null;
	region.nextRegion = null;
	region.animations = null;
}
function clearLayoutSlot(region) {
	context_default.previousRegion = region.previousRegion;
	clearRegion(region);
}
function newRegion(name) {
	return {
		startNode: null,
		endNode: null,
		previousRegion: null,
		nextRegion: null,
		depth: -1,
		animations: null,
		name
	};
}
function popRegion(oldRegion) {
	context_default.activeRegion = oldRegion;
}
function pushRegion(region, toParent = false) {
	const activeRegion = context_default.activeRegion;
	if (toParent) {
		const previousRegion = context_default.previousRegion;
		region.previousRegion = previousRegion;
		const nextRegion = previousRegion.nextRegion;
		previousRegion.nextRegion = region;
		region.nextRegion = nextRegion;
		region.depth = activeRegion.depth + 1;
	}
	context_default.activeRegion = region;
	context_default.previousRegion = region;
	devContext_default.onRegionPushed(region);
	return activeRegion;
}
function fillLayoutSlot(component, slot, parent, anchor, $props, $context) {
	const region = newRegion(devContext_default.enabled ? component.name : void 0);
	const oldRegion = pushRegion(region, true);
	component(parent, anchor, $props, $context, { _: slot });
	popRegion(oldRegion);
	return region;
}
function getFragment(document, array, index, html, ns) {
	if (array[index] === void 0) if (ns === true) {
		const template = document.createElementNS("http://www.w3.org/2000/svg", "template");
		template.innerHTML = html;
		const fragment = new DocumentFragment();
		fragment.append(...template.childNodes);
		array[index] = fragment;
	} else {
		const template = document.createElement("template");
		template.innerHTML = html;
		array[index] = template.content;
	}
	return array[index].cloneNode(true);
}
function hydrate(parent, component, props, slots) {
	context_default.hydrationNode = parent.firstChild;
	context_default.rootRegion = newRegion(devContext_default.enabled ? "Root" : void 0);
	context_default.previousRegion = context_default.rootRegion;
	pushRegion(context_default.rootRegion);
	component(parent, null, props, void 0, slots);
	context_default.hydrationNode = null;
	for (let effect of context_default.mountEffects) $run(effect);
	context_default.mountEffects.length = 0;
}
function mount(parent, component, props, slots) {
	if (parent.childElementCount > 0) throw new Error("The parent node must have no child elements");
	while (parent.firstChild !== null) parent.firstChild.remove();
	if (context_default.rootRegion === null) {
		context_default.rootRegion = newRegion(devContext_default.enabled ? "Root" : void 0);
		context_default.previousRegion = context_default.rootRegion;
		pushRegion(context_default.rootRegion);
	}
	component(parent, null, props, void 0, slots);
}
function newListItem(data, key) {
	return {
		startNode: null,
		endNode: null,
		previousRegion: null,
		nextRegion: null,
		depth: -1,
		animations: null,
		data,
		key
	};
}
const HYDRATION_START = "[";
const HYDRATION_END = "]";
const HYDRATION_BREAK = "^";
function isCommentNode(node) {
	return node.nodeType === 8;
}
function isTextNode(node) {
	return node.nodeType === 3;
}
function nodeCheckHydrationBreak(node) {
	if (context_default.hydrationNode !== null) {
		if (node !== null && isCommentNode(node) && node.data === HYDRATION_BREAK) {
			let comment = node;
			node = node.nextSibling;
			comment.remove();
		}
		context_default.hydrationNode = node;
	}
	return node;
}
function nodeNext(node, text = false) {
	if (context_default.hydrationNode !== null && text && isTextNode(node)) return node;
	return nodeCheckHydrationBreak(node.nextSibling);
}
function nodeAnchor(node) {
	if (context_default.hydrationNode !== null) {
		if (isCommentNode(node) && node.data === HYDRATION_START) {
			let currentNode = nodeNext(node);
			node.remove();
			let level = 1;
			while (currentNode !== null) {
				if (isCommentNode(currentNode)) {
					if (currentNode.data === HYDRATION_START) level += 1;
					else if (currentNode.data === HYDRATION_END) {
						level -= 1;
						if (level === 0) {
							const endNode = currentNode.nextSibling;
							currentNode.remove();
							if (context_default.hydrationNode === currentNode) context_default.hydrationNode = endNode;
							return endNode;
						}
					}
				}
				currentNode = currentNode.nextSibling;
			}
			if (currentNode === null) throw new Error("End hydration comment not found");
		}
	}
	return node;
}
function nodeChild(parent) {
	let childNode = parent.firstChild;
	if (context_default.hydrationNode !== null) {
		if (childNode === null) childNode = parent.appendChild(parent.ownerDocument.createTextNode(""));
		context_default.hydrationNode = childNode;
	}
	return childNode;
}
function nodeRoot(parent, text = false) {
	if (context_default.hydrationNode !== null) {
		let rootNode = context_default.hydrationNode;
		if (text && !isTextNode(rootNode) && rootNode.previousSibling !== null && isTextNode(rootNode.previousSibling)) {
			rootNode = rootNode.previousSibling;
			context_default.hydrationNode = rootNode;
		}
		if (isCommentNode(rootNode) && rootNode.data === HYDRATION_START) {
			rootNode = rootNode.nextSibling;
			context_default.hydrationNode = rootNode;
		}
		const region = context_default.activeRegion;
		if (region.startNode === null) region.startNode = rootNode;
		return rootNode;
	} else return parent.firstChild;
}
function nodeSkip(node, count) {
	let nextNode = node;
	for (let i = 0; i < count; i++) nextNode = nodeCheckHydrationBreak(nextNode.nextSibling);
	return nextNode;
}
function runControl(region, anchor, create) {
	const oldRegion = pushRegion(region, true);
	$run(function runControl$1() {
		const oldBranchRegion = pushRegion(region);
		create(anchor);
		popRegion(oldBranchRegion);
	});
	if (context_default.hydrationNode) anchor = context_default.hydrationNode.nextSibling;
	popRegion(oldRegion);
}
function runControlBranch(region, create, name) {
	if (region.depth === -2) return;
	if (region.nextRegion !== null && region.nextRegion.depth > region.depth) clearRegion(region.nextRegion);
	const oldRegion = pushRegion(newRegion(name), true);
	create();
	popRegion(oldRegion);
}
function moveRegion(parent, region, before) {
	parent = before?.parentNode ?? parent;
	const endNode = region.endNode ?? region.startNode;
	let currentNode = region.startNode;
	while (currentNode !== null) {
		const nextNode = currentNode.nextSibling;
		parent.insertBefore(currentNode, before);
		if (currentNode === endNode) break;
		currentNode = nextNode;
	}
}
function runListItems(region, parent, anchor, oldItems, newItems, create, update) {
	let oldStartIndex = 0;
	let oldEndIndex = oldItems.length - 1;
	let oldStartItem = oldItems[0];
	let oldEndItem = oldItems[oldEndIndex];
	let newStartIndex = 0;
	let newEndIndex = newItems.length - 1;
	let newStartItem = newItems[0];
	let newEndItem = newItems[newEndIndex];
	let oldKeyToIndex;
	let newKeyToIndex;
	while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) if (oldStartItem === null) oldStartItem = oldItems[++oldStartIndex];
	else if (oldEndItem === null) oldEndItem = oldItems[--oldEndIndex];
	else if (newStartItem === null) newStartItem = newItems[++newStartIndex];
	else if (newEndItem === null) newEndItem = newItems[--newEndIndex];
	else if (oldStartItem.key === newStartItem.key) {
		transferListItemData(oldStartItem, newStartItem, update);
		oldStartItem = oldItems[++oldStartIndex];
		newStartItem = newItems[++newStartIndex];
	} else if (oldEndItem.key === newEndItem.key) {
		transferListItemData(oldEndItem, newEndItem, update);
		oldEndItem = oldItems[--oldEndIndex];
		newEndItem = newItems[--newEndIndex];
	} else if (oldStartItem.key === newEndItem.key) {
		moveRegion(parent, oldStartItem, oldEndItem.endNode.nextSibling);
		transferListItemData(oldStartItem, newEndItem, update);
		oldStartItem = oldItems[++oldStartIndex];
		newEndItem = newItems[--newEndIndex];
	} else if (oldEndItem.key === newStartItem.key) {
		moveRegion(parent, oldEndItem, oldStartItem.startNode);
		transferListItemData(oldEndItem, newStartItem, update);
		oldEndItem = oldItems[--oldEndIndex];
		newStartItem = newItems[++newStartIndex];
	} else {
		if (oldKeyToIndex === void 0 || newKeyToIndex === void 0) {
			oldKeyToIndex = /* @__PURE__ */ new Map();
			for (let i = oldStartIndex; i < oldEndIndex; i++) oldKeyToIndex.set(oldItems[i].key, i);
			newKeyToIndex = /* @__PURE__ */ new Map();
			for (let i = newStartIndex; i < newEndIndex; i++) newKeyToIndex.set(newItems[i].key, i);
		}
		let oldIndex = oldKeyToIndex.get(newStartItem.key);
		let newIndex = newKeyToIndex.get(oldStartItem.key);
		if (oldIndex === void 0 && newIndex === void 0) {
			newStartItem.data = $watch(newStartItem.data, { shallow: true });
			create(newStartItem, oldStartItem.startNode);
			newStartItem.previousRegion = oldStartItem.previousRegion;
			newStartItem.nextRegion = oldStartItem;
			oldStartItem.previousRegion = newStartItem;
			clearRegion(oldStartItem);
			oldStartItem = oldItems[++oldStartIndex];
			newStartItem = newItems[++newStartIndex];
		} else if (oldIndex === void 0) {
			newStartItem.data = $watch(newStartItem.data, { shallow: true });
			create(newStartItem, oldStartItem.startNode);
			newStartItem = newItems[++newStartIndex];
		} else if (newIndex === void 0) {
			clearRegion(oldStartItem);
			oldStartItem = oldItems[++oldStartIndex];
		} else {
			const oldData = oldItems[oldIndex];
			moveRegion(parent, oldData, oldStartItem.startNode);
			transferListItemData(oldData, newStartItem, update);
			oldItems[oldIndex] = null;
			newStartItem = newItems[++newStartIndex];
		}
	}
	if (oldStartIndex <= oldEndIndex || newStartIndex <= newEndIndex) if (oldStartIndex > oldEndIndex) {
		let before = oldStartItem?.startNode ?? oldItems[oldItems.length - 1]?.endNode?.nextSibling ?? anchor;
		for (; newStartIndex <= newEndIndex; newStartItem = newItems[++newStartIndex]) {
			newStartItem.data = $watch(newStartItem.data, { shallow: true });
			create(newStartItem, before);
			before = newStartItem.endNode.nextSibling;
		}
	} else for (; oldEndIndex >= oldStartIndex; oldStartItem = oldItems[oldEndIndex--]) clearRegion(oldStartItem);
	if (newItems.length > 0) region.nextRegion = newItems[0];
	else if (oldItems.length > 0) region.nextRegion = oldItems[oldItems.length - 1].nextRegion;
}
function transferListItemData(oldItem, newItem, update) {
	newItem.startNode = oldItem.startNode;
	newItem.endNode = oldItem.endNode;
	update(oldItem, newItem);
	newItem.data = oldItem.data;
}
function runList(region, parent, anchor, buildItems, create, update) {
	const oldRegion = pushRegion(region, true);
	let listItems = [];
	$run(function runList$1() {
		const oldBranchRegion = pushRegion(region);
		const newItems = buildItems();
		context_default.activeTarget = null;
		runListItems(region, parent, anchor, listItems, newItems, create, update);
		listItems = newItems;
		popRegion(oldBranchRegion);
	});
	if (context_default.hydrationNode !== null) anchor = context_default.hydrationNode.nextSibling;
	popRegion(oldRegion);
}
function setAttribute(el, name, value) {
	if (value === false || value === void 0 || value === null) el.removeAttribute(name);
	else el.setAttribute(name, value);
}
function setDynamicElement(el, tag) {
	if (context_default.hydrationNode !== null) return el;
	let newElement = el.ownerDocument.createElement(tag);
	el.replaceWith(newElement);
	return newElement;
}
let initialized = false;
var ReactiveDate = class ReactiveDate extends Date {
	constructor(...params) {
		super(...params);
		if (!initialized) this.#init();
		this[proxyHandledSymbol] = true;
		this[proxyDataSymbol] = {
			target: this,
			isArray: false,
			shallow: true,
			signals: /* @__PURE__ */ new Map()
		};
	}
	#init() {
		initialized = true;
		let reactivePrototype = ReactiveDate.prototype;
		let datePrototype = Date.prototype;
		const methods = Object.getOwnPropertyNames(datePrototype);
		for (const method of methods) {
			if (method.startsWith("get") || method.startsWith("to") || method === "valueOf") reactivePrototype[method] = function(...args) {
				const data = this[proxyDataSymbol];
				const result = datePrototype[method].apply(this, args);
				trackProxySignal(data, "#time");
				return result;
			};
			if (method.startsWith("set")) reactivePrototype[method] = function(...args) {
				const data = this[proxyDataSymbol];
				const result = datePrototype[method].apply(this, args);
				propagateSignal(data, "#time");
				return result;
			};
		}
	}
};
let t_add_fragment = addFragment;
let t_anchor = nodeAnchor;
let t_animate = addAnimation;
let t_apply_props = applyProps;
let t_attribute = setAttribute;
let t_child = nodeChild;
let t_class = buildClasses;
let t_dynamic = setDynamicElement;
let t_event = addEvent;
let t_fmt = formatText;
let t_fragment = getFragment;
let t_list_item = newListItem;
let t_next = nodeNext;
let t_pop_region = popRegion;
let t_push_region = pushRegion;
let t_region = newRegion;
let t_root = nodeRoot;
let t_run_branch = runControlBranch;
let t_run_control = runControl;
let t_run_list = runList;
let t_skip = nodeSkip;
let t_style = buildStyles;
