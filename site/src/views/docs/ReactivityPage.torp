import Repl from "../repl/Repl.torp"

export default function ReactivityPage() {
	@head {
		<title>Reactivity | Torpor</title>
	}

	@render {
		<h1>Reactivity</h1>
		<p>
			Knowing how <a href="/state">state</a> works in Torpor is enough to get you up and
			running, but it may also be helpful to know a bit more about how reactivity works
			in more depth.
		</p>
		<p>
			The reactivity system is a <strong><em>pull-push-pull</em></strong> signaling system, similar to the
			systems used in other frameworks like Solid, Preact, Svelte and Vue. It was largely
			inspired by the <a href="https://preactjs.com/blog/signal-boosting/" target="_blank">Preact signals</a>
			implementation.
		</p>
		<p>
			In a reactivity system like this, the rough idea is that:
		</p>
		<ol>
			<li>Effect functions are run</li>
			<li>The effect functions <strong><em>pull</em></strong> values from signal containers</li>
			<li>The signal containers <strong><em>push</em></strong> their values to the effect functions when changed</li>
			<li>The effect functions re-run and <strong><em>pull</em></strong> new values from the signal objects</li>
		</ol>
		<p>
			The whole process is repeated many times, for as long as your components are in use.
		</p>
		
		<h2>Signals and effects</h2>
		<p>
			In Torpor, signals are created by using the <code>$watch</code> function to convert
			an object into a reactive Proxy object that we use to intercept property accesses:
		</p>
		<pre><code>{`
let $state = $watch({
	count: 1
})
`.trim()}</code></pre>
		<p>
			Each property accessor is essentially a signal that re-runs dependent effects when
			changed.
		</p>
		<p>
			Effects are created by using the <code>$run</code> function:
		</p>
		<pre><code>{`
$run(() => {
	console.log($state.count);
})
`.trim()}</code></pre>
		<p>
			When the property of a reactive object is accessed, a subscription from the property
			to the effect is created. When that property is subsequently updated, all of the
			effects that have subscribed to it will be re-run. In the course of that re-run, the
			subscription may be re-used, it may be disposed if no longer required, and new
			subscriptions may be created. All of this happens behind the scenes to keep your
			state and UI in sync.
		</p>

		<h2>Caching</h2>
		<p>
			You can use property getters to return a calculated value:
		</p>
		<pre><code>{`
let $state = $watch({
	count: 1,
	get isPrime() {
		if (this.count < 1) return false;
		for (let i = 2; i < this.count; i++) {
			if (this.count % i === 0) return false;
		}
		return true;
	}
})
`.trim()}</code></pre>
		<p>
			However, if you are accessing this property's value in multiple effects, it will
			be run over and over again, slowing down your application. To ensure that it's only
			run when its dependencies change, you can wrap the getter's implementation in a
			<code>$cache</code> function:
		</p>
		<pre><code>{`
let $state = $watch({
	count: 1,
	get isPrime() {
		return $cache(() => {
			if (this.count < 1) return false;
			for (let i = 2; i < this.count; i++) {
				if (this.count % i === 0) return false;
			}
			return true;
		});
	}
})
`.trim()}</code></pre>
		<p>
			Conceptually, cached signals sit somewhere between signals and effects, both
			pushing (when their value changes) and pulling (when they need to be re-run).
			Because of this, they complicate the dependency graph and use up memory, so you
			should only use them when you need to.
		</p>
		<p>
			In other frameworks cached signals may be called computed, derived, or memo(ized).
		</p>

		<h2>Playground</h2>
		<Repl input={`
export default function Component() {
	let $state = $watch({
		count: 1,
		get isPrime() {
			return $cache(() => {
				if (this.count < 1) return false;
				for (let i = 2; i < this.count; i++) {
					if (this.count % i === 0) return false;
				}
				return true;
			});
		}
	})

	@render {
		<p id="text">
			The count is {$state.count} and it is {$state.isPrime ? "" : "not"} prime.
		</p>
		<button onclick={() => $state.count++}>
			Increment
		</button>
		<button onclick={() => $state.count = 0}>
			Reset
		</button>
	}
}
`.trimStart()} />
	}
}
