import type { ClassValue, StyleValue } from "@torpor/view";
import getId from "../utils/getId";
import {
	type ItemState,
	type TreeContext,
	TreeContextName,
	type TreeItemContext,
	TreeItemContextName,
} from "./TreeTypes";

interface TreeItemProps {
	/** An ID for the root element */
	id?: string;
	/** Classes for the root element */
	class?: ClassValue;
	/** Styles for the root element */
	style?: StyleValue;
	/** A value for the item */
	value?: string;
	/** If set to true, the user cannot interact with this TreeItem */
	disabled?: boolean;
	/** Raised when this item is expanded or collapsed */
	onExpand?: (expanded: boolean) => void;
	/** Raised when this item is selected or deselected */
	onSelect?: (selected: boolean) => void;
}

/**
 * An item in a Tree, which can contain nested TreeItems via TreeItemChildren.
 *
 * The structure of a TreeItem is:
 *
 * ```
 * <TreeItem>
 * 	<TreeItemContent>
 * 		<TreeItemTrigger />
 * 		<TreeItemLabel />
 * 	</TreeItemContent>
 * 	<TreeItemChildren>
 * 		<TreeItem />
 * 	</TreeItemChildren>
 * </TreeItem>
 * ```
 */
export default function TreeItem($props: TreeItemProps | undefined) {
	let defaultId = getId();

	const parentContext = $context[TreeItemContextName] as TreeItemContext;
	const level = parentContext ? parentContext.state.level + 1 : 0;

	let $state: ItemState = $watch({
		id: $props?.id ?? defaultId,
		index: -1,
		value: $props?.value ?? "",
		expanded: false,
		selected: false,
		disabled: $props?.disabled ?? false,
		parentDisabled: false,
		level,
		hasChildren: false,
		setFocused,
	});

	const context = $context[TreeContextName] as TreeContext;
	if (!context) {
		throw new Error("TreeItem must be contained within a Tree");
	}

	//$run(() => {
	//	let parentLevel = $state.level;
	//	$state.level = parentLevel + 1;
	//});

	context.registerItem($state, $state.level);

	$run(() => {
		return () => {
			context.removeItem($state.index);
		};
	});

	$run(() => {
		const onExpand = $props?.onExpand;
		const expanded = $state.expanded;
		if (onExpand) {
			onExpand(expanded);
		}
	});

	$run(() => {
		const onSelect = $props?.onSelect;
		const selected = $state.selected;
		if (onSelect) {
			onSelect(selected);
		}
	});

	let focusLabel: (() => void) | undefined;

	function setFocused() {
		focusLabel?.();
	}

	let itemContext: TreeItemContext = {
		state: $state,
		setHasChildren: (hasChildren) => {
			$state.hasChildren = hasChildren;
		},
	};
	$context[TreeItemContextName] = itemContext;

	@render {
		<div
			{$state.id}
			class={["torp-tree-item", $props?.class]}
			{$props?.style}
			role="treeitem"
			aria-level={$state.level + 1}
			aria-selected={$state.selected ? "true" : "false"}
			aria-disabled={$state.disabled || $state.parentDisabled ? "true" : undefined}
			data-selected={$state.selected ? "selected" : undefined}
			data-disabled={$state.disabled || $state.parentDisabled ? "true" : undefined}
		>
			@// HACK: May be better to do this with CSS?
			@if ($state.level) {
				<div style="display: flex">
					<div class={["torp-tree-item", $props?.class, "spacer"]} />
					<div>
						<slot />
					</div>
				</div>
			} else {
				<div>
					<slot />
				</div>
			}
		</div>
	}
}
