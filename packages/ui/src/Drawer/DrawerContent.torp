import { addDocumentEvent, removeDocumentEvent } from "../utils/documentEvents";
import { DrawerContextName, type DrawerContext } from "./DrawerTypes";

interface DrawerContentProps {
	/** An ID for the root element */
	id?: string;
	/** Class name(s) for the root element */
	class?: string,
}

/**
 * The content that is displayed for a Drawer when it is open.
 */
export default function DrawerContent($props?: DrawerContentProps) {
	$props ??= $watch({});

	// HACK:
	if (!$props) return;

	let drawer: HTMLElement;
	let shown = false;
	let closeOnClick = false;

	// Get stuff out of the DrawerContext
	const context = $context[DrawerContextName] as DrawerContext;
	if (!context) {
		throw new Error("DrawerContent must be contained within a Drawer");
	}
	let $state = context.state;

	$run(() => {
		if (!$state.visible) {
			hide();
		}
	});

	function show() {
		shown = true;

		// HACK: Because this Drawer could be shown with a click, we need to wait for another mousedown
		// before we close on click. Otherwise the click immediately bubbles to the document
		closeOnClick = false;
		addDocumentEvent("mousedown", handleDocumentMouseDown);
		addDocumentEvent("click", handleDocumentClick);

		// Set the position and listen for window resize and scroll to reset the position
		//setPosition();
	}

	function hide() {
		if (!shown) return;

		removeDocumentEvent("mousedown", handleDocumentMouseDown);
		removeDocumentEvent("click", handleDocumentClick);
	}

	function handleDocumentMouseDown() {
		closeOnClick = true;
	}

	function handleDocumentClick(e: MouseEvent) {
		if (
			closeOnClick &&
			drawer &&
			!drawer.contains(e.target as HTMLElement)
		) {
			e.preventDefault();
			context.handleClickOutside!(e);
		}
	}

	// From https://stackoverflow.com/a/46707458
	function measure(el: HTMLElement, fn: (_: HTMLElement) => any) {
		let oldVisibility = el.style.visibility;
		let oldPosition = el.style.position;

		let oldParent = el.parentNode;
		let oldBefore = el.nextNode;

		el.style.visibility = "hidden";
		el.style.position = "absolute";

		document.body.appendChild(el);
		let result = fn(el);
		el.parentNode.removeChild(el);

		oldParent.appendChild(el, oldBefore);
		el.style.visibility = oldVisibility;
		el.style.position = oldPosition;

		return result;
	}

	function transitionArgs() {
		if (drawer) {
			switch ($state.position) {
				case "left": {
					drawer.style.left = "0px";
					const width = measure(drawer, (el) => el.offsetWidth);
					return [
						{ transform: `translateX(-${width}px)` },
						{ transform: "translateX(0px)" }
					];
				}
				case "top": {
					drawer.style.top = "0px";
					const height = measure(drawer, (el) => el.offsetHeight);
					return [
						{ transform: `translateY(-${height}px)` },
						{ transform: "translateY(0px)" }
					];
				}
				case "right": {
					drawer.style.right = "0px";
					const width = measure(drawer, (el) => el.offsetWidth);
					return [
						{ transform: `translateX(${width}px)` },
						{ transform: "translateX(0px)" }
					];
				}
				case "bottom": {
					drawer.style.bottom = "0px";
					const height = measure(drawer, (el) => el.offsetHeight);
					return [
						{ transform: `translateY(${height}px)` },
						{ transform: "translateY(0px)" }
					];
				}
			}
		}
	}

	@render {
		@if ($state.visible) {
			<div
				{$props.id}
				class={`torp-drawer-content ${$props.class ?? ""}`.trim()}
				style="position: fixed;"
				transition={transitionArgs()}
				&ref={drawer}
				onmount={show}
			>
				<slot />
			</div>
		}
	}
}
