
import { addDocumentEvent, removeDocumentEvent } from "../utils/documentEvents";
import getScrollParent from "../utils/getScrollParent";
import setContextPosition from "../utils/setContextPosition";
import { ContextualContextName, type ContextualContext } from "./ContextualTypes";

interface ContextualContentProps {
	/** An ID for the root element */
	id?: string;
	/** Class name(s) for the root element */
	class?: string,
}

/**
 * The content that is displayed for a Contextual when it is open, displayed at the
 * position that the user right-clicked.
 */
export default function ContextualContent($props: ContextualContentProps) {	
	$props ??= $watch({});

	let div: HTMLDivElement;
	let shown = false;
	let closeOnClick = false;

	// Get stuff out of the ContextualContext
	const context = $context[ContextualContextName] as ContextualContext;
	if (!context) {
		throw new Error("ContextualContent must be contained within a Contextual");
	}
	let $state = context.state;

	$run(() => {
		if (!$state.visible) {
			hide();
		}
	});

	function show() {
		shown = true;

		// HACK: Because this Contextual could be shown with a click, we need to wait for another mousedown
		// before we close on click. Otherwise the click immediately bubbles to the document
		closeOnClick = false;
		addDocumentEvent("mousedown", handleDocumentMouseDown);
		addDocumentEvent("click", handleDocumentClick);

		// Set the position and listen for window resize and scroll to reset the position
		setPosition();
		const scrollParent = getScrollParent(context.anchorElement)
		scrollParent.addEventListener("resize", setPosition);
		scrollParent.addEventListener("scroll", setPosition);
		if (context.focusFirstElement) {
			context.focusFirstElement();
		}
	}

	function hide() {
		if (!shown) return;

		removeDocumentEvent("mousedown", handleDocumentMouseDown);
		removeDocumentEvent("click", handleDocumentClick);

		// Stop listening for window resize and focus the anchor element per WAI guidelines
		const scrollParent = getScrollParent(context.anchorElement)
		scrollParent.removeEventListener("resize", setPosition);
		scrollParent.removeEventListener("scroll", setPosition);
		if (context.anchorElement?.focus) {
			context.anchorElement.focus();
		}
	}

	function handleDocumentMouseDown() {
		closeOnClick = true;
	}

	function handleDocumentClick(e: MouseEvent) {
		if (
			closeOnClick &&
			div &&
			!div.contains(e.target as HTMLElement) &&
			(!context.anchorElement || !context.anchorElement.contains(e.target as HTMLElement))
		) {
			context.handleClickOutside!(e);
		}
	}

	function setPosition() {
		if (!context.anchorElement) {
			throw new Error("ContextualContent must have an anchor element");
		}

		if ($state.position) {
			setContextPosition(context.anchorElement, div, $state.position);
		}
	}

	@render {
		@if ($state.visible) {
			<div
				{$props.id}
				class={`torp-popover-content-contextual ${$props.class ?? ""}`.trim()}
				&ref={div}
				onmount={show}
			>
				<slot />
			</div>
		}
	}
}
