import type { ClassValue, StyleValue } from "@torpor/view";
import { type AccordionContext, AccordionContextName, type ItemState } from "./AccordionTypes";

interface AccordionProps {
	/** An ID for the root element */
	id?: string;
	/** Classes for the root element */
	class?: ClassValue;
	/** Styles for the root element */
	style?: StyleValue;
	/** Whether a single AccordionItem or multiple AccordionItems can be expanded at the same time */
	type?: "single" | "multiple";
	/** The value of the expanded AccordionItem, or an array of values if the type is "multiple" */
	value?: any | any[];
	/** If set to true, the user cannot interact with any items in the Accordion */
	disabled?: boolean;
	/** Raised when the expanded item(s) have changed */
	onchange?: (value: any | any[]) => void;
}

/**
 * A vertically stacked set of interactive headings that enable users to reveal
 * or hide associated sections of content.
 *
 * See [the WAI ARIA guidelines for Accordions](https://www.w3.org/WAI/ARIA/apg/patterns/accordion/).
 *
 * The structure of an Accordion is:
 *
 * ```
 * <Accordion>
 * 	<AccordionItem>
 * 		<AccordionHeader>
 * 			<AccordionTrigger />
 * 		</AccordionHeader>
 * 		<AccordionContent />
 * 	</AccordionItem>
 * </Accordion>
 * ```
 */
export default function Accordion($props: AccordionProps | undefined) {
	let type = $props?.type ?? "single";

	let $state = $watch({
		value: $props?.value ?? (type === "single" ? undefined : []),
	});

	// Update $state on $props change
	$run(() => {
		$state.value = $props?.value ?? (type === "single" ? undefined : []);
	});

	// Update $props on $state change
	$run(() => {
		if ($props !== undefined) {
			$props.value = $state.value;
		}
	});

	let itemStates: ItemState[] = [];

	// This is used to assign automatic indexes to items where needed
	let nextIndex = 0;

	// Set the context to pass down to items, with functions for each item to call
	let context: AccordionContext = {
		registerItem,
		removeItem,
		toggleItem,
		handleHeaderKey,
	};
	$context[AccordionContextName] = context;

	$run(() => {
		// Get the value to ensure that this effect will be subscribed
		let value = $state.value;

		// And set the expanded item(s)
		switch (type) {
			case "single": {
				for (let item of itemStates) {
					item.expanded = item.value === value;
				}
				break;
			}
			case "multiple": {
				if (!Array.isArray(value)) {
					value = [value];
				}
				for (let item of itemStates) {
					item.expanded = value.indexOf(item.value) !== -1;
				}
				break;
			}
		}
	});

	$run(() => {
		let disabled = $props?.disabled;
		itemStates.forEach((s) => (s.parentDisabled = disabled === true));
	});

	// Dispatch the change event when the value changes
	let firstChange = true;
	$run(() => {
		const onchange = $props?.onchange;
		const value = $state.value;
		if (firstChange) {
			firstChange = false;
		} else if (onchange) {
			onchange(value);
		}
	});

	function registerItem(itemState: ItemState) {
		// If an index wasn't set for the item, set it automatically
		if (itemState.index === -1) {
			itemState.index = nextIndex++;
		}

		// If a value wasn't set for the item, set it to the index
		if (!itemState.value) {
			itemState.value = itemState.index;
		}

		// If we have a value, set whether the item should be expanded
		if ($state.value !== undefined && $state.value !== null) {
			switch (type) {
				case "single": {
					itemState.expanded = $state.value === itemState.value;
					break;
				}
				case "multiple": {
					itemState.expanded = $state.value.includes(itemState.value);
					break;
				}
			}
		}

		// Set whether the Accordion itself is disabled
		itemState.parentDisabled = $props?.disabled === true;

		// Add the item's state to the array
		itemStates.splice(itemState.index, 0, itemState);
	}

	// TODO: I think this should be done by value
	function removeItem(itemIndex: number) {
		// Remove the item and re-index
		let index = itemStates.findIndex((item) => item.index === itemIndex);
		if (index !== -1) {
			itemStates.splice(index, 1);
		}
		itemStates.forEach((item, i) => (item.index = i));
	}

	function toggleItem(toggleValue: string) {
		switch (type) {
			case "single": {
				for (let item of itemStates) {
					// The item is expanded if it has the supplied value (i.e. if it was clicked) and if it
					// wasn't already expanded (i.e. we collapse it if it was expanded and clicked)
					if (item.value === toggleValue) {
						$state.value = item.expanded ? undefined : item.value;
						break;
					}
				}
				break;
			}
			case "multiple": {
				let value = [];
				for (let item of itemStates) {
					// The item is expanded if it has the supplied value (i.e. if it was clicked) or if it
					// was already expanded
					if (
						(item.value === toggleValue && !item.expanded) ||
						(item.value !== toggleValue && item.expanded)
					) {
						value.push(item.value);
					}
				}
				$state.value = value.sort();
				break;
			}
		}
	}

	function handleHeaderKey(headerIndex: number, e: KeyboardEvent) {
		switch (e.key) {
			case "Up":
			case "ArrowUp": {
				for (let i = headerIndex - 1; i >= 0; i--) {
					if (!itemStates[i].disabled) {
						e.preventDefault();
						itemStates[i].setFocused();
						break;
					}
				}
				break;
			}
			case "Down":
			case "ArrowDown": {
				for (let i = headerIndex + 1; i < itemStates.length; i++) {
					if (!itemStates[i].disabled) {
						e.preventDefault();
						itemStates[i].setFocused();
						break;
					}
				}
				break;
			}
			case "Home": {
				for (let i = 0; i < itemStates.length; i++) {
					if (!itemStates[i].disabled) {
						e.preventDefault();
						itemStates[i].setFocused();
						break;
					}
				}
				break;
			}
			case "End": {
				for (let i = itemStates.length - 1; i >= 0; i--) {
					if (!itemStates[i].disabled) {
						e.preventDefault();
						itemStates[i].setFocused();
						break;
					}
				}
				break;
			}
		}
	}

	@render {
		<div {$props?.id} class={["torp-accordion", $props?.class]} {$props?.style}>
			<slot />
		</div>
	}
}
