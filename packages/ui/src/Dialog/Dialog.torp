import type { ClassValue, StyleValue } from "@torpor/view";
import getId from "../utils/getId";
import { trapFocus, type TrapFocusOptions } from "../mount/trapFocus";
import { ModalContextName, type ModalContext } from "../Modal/ModalTypes";
import { PopoverContextName } from "../Popover/PopoverTypes";
import { DialogContextName, type DialogContext, type DialogState, type HandleButtonPress } from "./DialogTypes";

interface DialogProps {
	/** An ID for the root element */
	id?: string;
	/** Classes for the root element */
	class?: ClassValue,
	/** Styles for the root element */
	style?: StyleValue,
	/** An ARIA label for describing the popover to screen readers  */
	ariaLabel?: string,
	/** Whether the dialog should alert the user via the screen reader */
	alert?: boolean,
}

/**
 * A dialog that can be used to show a message to the user, or get information from the user.
 * 
 * Dialogs are typically shown within a Modal or Popover.
 * 
 * See [the WAI ARIA guidelines for Dialogs](https://www.w3.org/WAI/ARIA/apg/patterns/dialogmodal/).
 * 
 * The structure of a Dialog is:
 * 
 * ```
 * <Dialog>
 * 	<ModalOverlay /> (optional -- will set `modal` to true)
 * 	<DialogHeader /> (optional)
 * 	<DialogBody /> (optional)
 * 	<DialogFooter> (optional)
 * 		<DialogButton /> (optional)
 * 	</DialogFooter>
 * </Dialog>
 * ```
 * 
 */
export default function Dialog($props: DialogProps | undefined) {
	let defaultId = getId();

	//let div: HTMLDivElement;

	let trapFocusOptions: TrapFocusOptions = {
		focusableElements: []
	};

	// Maybe get stuff out of a Modal context
	let modal = false;
	let visible = true;
	let handleButton: HandleButtonPress | undefined = undefined;
	const modalContext = $context[ModalContextName] ?? $context[PopoverContextName] as ModalContext;
	if (modalContext) {
		modal = true;
		visible = modalContext.state.visible;
		handleButton = modalContext.handleButton;

		modalContext.handleClickOutside = handleClickOutside;
		// Set the focusFirstElement method in the ModalContext so that it can be
		// called after everything has been shown
		modalContext.focusFirstElement = focusFirstElement;
	}

	// Set the IDs for using in the Dialog's ARIA attributes
	let $state: DialogState = $watch({
		dialogId: $props?.id ?? defaultId,
		headerId: "",
		bodyId: "",
		visible
	})

	// Set the context to pass down to items
	let context: DialogContext = {
		handleButton,
		state: $state,
		anchorElement: modalContext ? modalContext.anchorElement : undefined
	};
	$context[DialogContextName] = context;

	function focusFirstElement() {
		if (trapFocusOptions.focusableElements.length) {
			trapFocusOptions.focusableElements[0].focus();
		}
	}

	function handleClickOutside(e: MouseEvent) {
		// Don't allow the user to click outside -- they must press a button or
		// the Esc key
		e.preventDefault();
		if (!modal) {
			modalContext.state.visible = false;
		}
	}

	function handleKey(e: KeyboardEvent) {
		switch (e.key) {
			case "Esc":
			case "Escape": {
				if (context.cancelButton) {
					context.cancelButton.click();
					e.preventDefault();
				}
				break;
			}
			case "Enter": {
				if (context.confirmButton) {
					context.confirmButton.click();
					e.preventDefault();
				}
				break;
			}
		}
	}

	@render {
		<div
			id={$props?.id ?? defaultId}
			class={["torp-dialog", $props?.class]}
			{$props?.style}
			tabindex="0"
			role={$props?.alert === true ? "alertdialog" : "dialog"}
			aria-modal={modal}
			aria-label={$props?.ariaLabel}
			aria-labelledby={!$props?.ariaLabel && $state.headerId ? $state.headerId : undefined}
			aria-describedby={$state.bodyId ? $state.bodyId : undefined}
			onkeydown={handleKey}
			onmount={(el) => trapFocus(el, trapFocusOptions)}
			@//&ref={div}
		>
			<slot />
		</div>
	}
}
