import type { ClassValue, StyleValue } from "@torpor/view";
import {
	type HandleButtonPress,
	type PopoutContext,
	PopoutContextName,
} from "../utils/PopoutTypes";
import getId from "../utils/getId";
import { type ItemState, type ListBoxContext, ListBoxContextName } from "./ListBoxTypes";

// TODO: orientation

interface ListBoxProps {
	/** An ID for the root element */
	id?: string;
	/** Classes for the root element */
	class?: ClassValue;
	/** Styles for the root element */
	style?: StyleValue;
	/** Whether a single ListBoxItem or multiple ListBoxItems can be selected at the same time */
	type?: "single" | "multiple";
	/** The value of the selected ListBoxItem, or an array of values if the type is "multiple" */
	value?: any | any[];
	/** If set to true, the user cannot interact with any items in the ListBox */
	disabled?: boolean;
	/** An ARIA label for describing the ListBox to screen readers  */
	ariaLabel?: string | undefined;
	/** An ID of an element that labels the ListBox */
	ariaLabelledBy?: string | undefined;
	/** The orientation of the ListBox */
	orientation?: "vertical" | "horizontal";
	/** Raised when the selected item(s) have changed */
	onchange?: (value: any | any[]) => void;
}

/**
 * A list of options that a user can select.
 *
 * See [the WAI ARIA guidelines for ListBoxes](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/).
 *
 * The structure of an ListBox is:
 *
 * ```
 * <ListBox>
 * 	<ListBoxItem />
 * 	<ListBoxSeparator /> (optional)
 * </ListBox>
 * ```
 */
export default function ListBox($props: ListBoxProps | undefined) {
	let defaultId = getId();
	let type = $props?.type ?? "single";

	// This may come from a PopoutContext, or we may need to handle it ourselves
	let searchText: string | undefined;

	let $state = $watch({
		value: $props?.value ?? (type === "single" ? undefined : []),
	});

	// Update $state on $props change
	$run(() => {
		$state.value = $props?.value ?? (type === "single" ? undefined : []);
	});

	// Update $props on $state change
	$run(() => {
		if ($props !== undefined) {
			$props.value = $state.value;
		}
	});

	let itemStates: ItemState[] = [];

	// This is used to assign automatic indexes to items where needed
	let nextIndex = 0;

	// Maybe get stuff out of a popout context
	let handleButton: HandleButtonPress | undefined = undefined;
	const popoutContext = $context[PopoutContextName] as PopoutContext;
	if (popoutContext) {
		handleButton = popoutContext.handleButton;

		//popoutContext.handleClickOutside = handleClickOutside;
		// Set the focusFirstElement method in the PopoutContext so that it can be
		// called after everything has been shown
		popoutContext.focusFirstElement = focusFirstElement;
		popoutContext.focusLastElement = focusLastElement;
		popoutContext.markElement = markElement;
		popoutContext.selectMarkedElement = selectMarkedElement;
		popoutContext.searchItems = searchItems;

		// Set the content ID so that it can be used with aria-controls in AccordionTrigger
		popoutContext.state.contentId = $props?.id ?? defaultId;
	}

	// Set the context to pass down to items, with functions for each item to call
	let context: ListBoxContext = {
		type,
		state: $state,
		registerItem,
		removeItem,
		toggleItem,
		handleKey,
	};
	$context[ListBoxContextName] = context;

	function focusFirstElement() {
		if (itemStates.length > 0) {
			itemStates[0].setFocused();
		}
	}

	function focusLastElement() {
		if (itemStates.length > 0) {
			itemStates.at(-1)!.setFocused();
		}
	}

	function markElement(id: string) {
		itemStates.forEach((i) => {
			i.selected = false;
			i.active = i.id === id;
		});
	}

	function selectMarkedElement() {
		const marked = itemStates.find((i) => i.active === true);
		if (marked && handleButton) {
			handleButton("confirm", marked.value);
		}
	}

	function searchItems(searchText: string) {
		const normalizedSearchText = searchText.toLocaleLowerCase();
		for (let item of itemStates) {
			if (item.text.toLocaleLowerCase().includes(normalizedSearchText)) {
				return item;
			}
		}
	}

	$run(() => {
		// Get the value to ensure that this effect will be subscribed
		let value = $state.value;

		// And set the expanded item(s)
		switch (type) {
			case "single": {
				for (let item of itemStates) {
					item.selected = item.value === value;
				}
				break;
			}
			case "multiple": {
				if (!Array.isArray(value)) {
					value = [value];
				}
				for (let item of itemStates) {
					item.selected = value.indexOf(item.value) !== -1;
				}
				break;
			}
		}
	});

	$run(() => {
		let disabled = $props?.disabled;
		itemStates.forEach((s) => (s.parentDisabled = disabled === true));
	});

	// Dispatch the change event when the value changes
	let firstChange = true;
	$run(() => {
		const onchange = $props?.onchange;
		const value = $state.value;
		if (firstChange) {
			firstChange = false;
		} else if (onchange) {
			onchange(value);
		}
	});

	function registerItem(itemState: ItemState) {
		// If an index wasn't set for the item, set it automatically
		if (itemState.index === -1) {
			itemState.index = nextIndex++;
		}

		// If we have a value, set whether the item should be selected
		if ($state.value !== undefined && $state.value !== null) {
			switch (type) {
				case "single": {
					itemState.selected = $state.value === itemState.value;
					break;
				}
				case "multiple": {
					itemState.selected = $state.value.includes(itemState.value);
					break;
				}
			}
		}

		// Set whether the ListBox itself is disabled
		itemState.parentDisabled = $props?.disabled === true;

		// Add the item's state to the array
		itemStates.splice(itemState.index, 0, itemState);
	}

	// TODO: I think this should be done by value
	function removeItem(itemIndex: number) {
		// Remove the item and re-index
		let index = itemStates.findIndex((item) => item.index === itemIndex);
		if (index !== -1) {
			itemStates.splice(itemIndex, 1);
		}
		itemStates.forEach((item, i) => (item.index = i));
	}

	function toggleItem(value: string) {
		switch (type) {
			case "single": {
				// Set the value
				for (let item of itemStates) {
					if (item.value === value) {
						$state.value = item.selected ? undefined : item.value;
						break;
					}
				}
				// Clear selected and active for all the items based on the value that was set
				for (let item of itemStates) {
					item.selected = $state.value === item.value;
					item.active = false;
				}
				// Pass this along to the containing popout if applicable, so
				// that the popout can be closed
				if (handleButton) {
					handleButton("confirm", value);
				}
				break;
			}
			case "multiple": {
				let newValue = [];
				for (let item of itemStates) {
					if ((item.value === value && !item.selected) || (item.value !== value && item.selected)) {
						newValue.push(item.value);
					}
				}
				$state.value = newValue.sort();
				// Pass this along to the containing popout if applicable, so
				// that the popout can be updated
				if (handleButton) {
					handleButton(undefined, $state.value);
				}
				break;
			}
		}
	}

	function handleKey(index: number, e: KeyboardEvent) {
		switch (e.key) {
			case "Up":
			case "ArrowUp": {
				if (index > 0) {
					e.preventDefault();
					itemStates[index - 1].setFocused();
					if (popoutContext) {
						popoutContext.searchText = undefined;
					} else {
						searchText = undefined;
					}
				}
				break;
			}
			case "Down":
			case "ArrowDown": {
				if (index < itemStates.length - 1) {
					e.preventDefault();
					itemStates[index + 1].setFocused();
					if (popoutContext) {
						popoutContext.searchText = undefined;
					} else {
						searchText = undefined;
					}
				}
				break;
			}
			case "Home": {
				if (index > 0) {
					e.preventDefault();
					itemStates[0].setFocused();
					if (popoutContext) {
						popoutContext.searchText = undefined;
					} else {
						searchText = undefined;
					}
				}
				break;
			}
			case "End": {
				if (index < itemStates.length - 1) {
					e.preventDefault();
					itemStates[itemStates.length - 1].setFocused();
					if (popoutContext) {
						popoutContext.searchText = undefined;
					} else {
						searchText = undefined;
					}
				}
				break;
			}
			case "Escape": {
				if (handleButton) {
					handleButton("cancel");
					if (popoutContext) {
						popoutContext.searchText = undefined;
					} else {
						searchText = undefined;
					}
				}
				break;
			}
			case "Backspace": {
				if (popoutContext?.searchText || searchText) {
					e.preventDefault();
					const shorten = (str: string) => str.substring(0, str.length - 1);
					if (popoutContext) {
						popoutContext.searchText = shorten(popoutContext.searchText!);
						searchText = popoutContext.searchText;
					} else {
						searchText = shorten(searchText!);
					}
					if (searchText.length > 0) {
						const found = searchItems(searchText);
						if (found) {
							found.setFocused();
						}
					}
				}
				break;
			}
			default: {
				// TODO: Handle unicode
				if (e.key.length === 1) {
					e.preventDefault();
					const lengthen = (str: string) => (str ??= "") + e.key;
					if (popoutContext) {
						popoutContext.searchText = lengthen(popoutContext.searchText!);
						searchText = popoutContext.searchText;
					} else {
						searchText = lengthen(searchText!);
					}
					const found = searchItems(searchText);
					if (found) {
						found.setFocused();
					}
				}
			}
		}
	}

	@render {
		<div
			id={$props?.id ?? defaultId}
			class={["torp-list-box", $props?.class]}
			{$props?.style}
			role="listbox"
			aria-label={$props?.ariaLabel}
			aria-labelledby={$props?.ariaLabelledBy}
			aria-multiselectable={type === "multiple" ? "true" : undefined}
			aria-disabled={$props?.disabled ? "true" : undefined}
			aria-orientation={$props?.orientation}
		>
			<slot />
		</div>
	}
}
