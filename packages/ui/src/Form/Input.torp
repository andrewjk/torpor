import getId from "../utils/getId";
import { FormContextName, FieldContextName, type FormContext, type FieldContext } from "./FormTypes";

interface InputProps {
	/** An ID for the root element */
	id?: string;
	/** Class name(s) for the root element */
	class?: string,
	/** The input type */
	type?: "text" | "number" | "password" | "email" | "url" | "tel",
	/** The name of the input's form data field */
	name?: string,
	/** The data value that this field is bound to */
	value?: any,
	/** Text to display when the input value is empty */
	placeholder?: string,
	/** Whether the input should be readonly */
	readonly?: boolean,
	/** Whether the input's value is required */
	required?: boolean,
	/** The maximum number of characters allowed for the input value */
	maxlength?: number,
	/** An ARIA label for describing the input to screen readers when there is no associated label element */
	ariaLabel?: string,
	/** Raised on change */
	onchange?: (e: Event) => void,
	/** Raised on input */
	oninput?: (e: Event) => void,
};

/**
 * A standard input in a form.
 */
export default function Input($props: InputProps | undefined) {
	let defaultId = getId();

	let type = $props?.type ?? "text";
	let name = $props?.name

	let blurred = false;

	// Get stuff out of the FormContext and FieldContext
	const formContext = $context[FormContextName] as FormContext;
	const fieldContext = $context[FieldContextName] as FieldContext;
	if (fieldContext) {
		name ??= fieldContext.name;
	}

	// Use the FieldContext's state, or create a new one
	let $state = fieldContext?.state ?? $watch({
		inputId: $props?.id ?? defaultId,
		value: $props?.value,
		errors: {} as Record<string, string>,
		valid: false,
		message: "",
	});

	// Binding
	$run(() => {
		if ($props !== undefined) {
			$props.value = $state.value;
		}
	});

	// Set the input ID now that we know it and it will get linked with the associated label
	$state.inputId = $props?.id ?? defaultId;

	// NOTE: Adapted this from https://stackoverflow.com/a/57393751,
	// not sure if it's still a good way to do things
	function handleInput(e: Event & { currentTarget: EventTarget & HTMLInputElement }) {
		$state.value = $props!.type?.match(/^(number|range)$/) ? +e.currentTarget.value : e.currentTarget.value;
		if (formContext) {
			formContext.validate();
		}
		if (fieldContext && blurred) {
			fieldContext.validate();
		}
		if ($props?.oninput) {
			$props.oninput(e);
		}
	}

	function handleBlur() {
		if (fieldContext) {
			fieldContext.validate();
		}
		blurred = true;
	}

	@render {
		<input
			id={$props?.id ?? defaultId}
			class={`torp-input ${$props?.class ?? ""}`.trim()}
			{type}
			{name}
			&value={$state.value}
			{$props?.placeholder}
			{$props?.readonly}
			{$props?.required}
			{$props?.maxlength}
			aria-label={$props?.ariaLabel}
			data-valid={$state.valid ? "valid" : "invalid"}
			onchange={$props?.onchange}
			oninput={handleInput}
			onblur={handleBlur}
		/>
	}
}
